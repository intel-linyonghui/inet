\chapter{The Physical Layer (Transceiver Modeling)}
\label{cha:physicallayer}

\section{Overview}

Wireless network interfaces contain a radio model component, which is
responsible for modeling the physical layer (PHY).\footnote{Wired network interfaces
could similarly contain an explicit PHY model. The reason they do not is that
wired links normally have very low error rates and simple observable behavior,
and there is usually not much to be gained from modeling the physical layer in detail.}
The radio model describes the physical device that is capable of transmitting
and receiving signals on the medium. 

Conceptually, a radio model relies on several sub-models:

\begin{itemize}
  \item antenna model
  \item transmitter model 
  \item receiver model 
  \item error model (as part of the receiver model)
  \item energy consumption model 
\end{itemize}

The antenna model is shared between the transmitter model and the receiver model.
The separation of the transmitter model and the receiver model allows 
asymmetric configurations. The energy consumer model is optional, and 
it is only used when the simulation of energy consumption is necessary.

TODO multiple implementations are provided for each model. For different
level of detail (abstract/fast versus detailed), different modeling strategy, etc.

TODO explain scalar, dimensional, and ``layered''

TODO different signal representations for models of different detail levels, etc.

\section{Generic Radio}

In INET, radio models implement the \nedtype{IRadio} module interface. 
A generic, often used implementation of \nedtype{IRadio} is the 
\nedtype{Radio} NED type. \nedtype{Radio} is an active compound module, 
that is, it has an associated C++ class that encapsulates the computations.

\nedtype{Radio} contains its antenna, transmitter, receiver and energy
consumer models as submodules with parametric types:

\begin{ned}
antenna: <antennaType> like IAntenna;
transmitter: <transmitterType> like ITransmitter;
receiver: <receiverType> like IReceiver;
energyConsumer: <energyConsumerType> like IEnergyConsumer 
    if energyConsumerType != "";
\end{ned}

\nedtype{Radio} has several specialized versions where submodule types
are set to a specific model type. For example, \nedtype{ApskScalarRadio} 
contains \nedtype{IsotropicAntenna}, \nedtype{ApskScalarTransmitter},
and \nedtype{ApskScalarTransmitter}. 

The following sections describe the parts of the radio model.

\section{Components of a Radio}

\subsection{Antenna Models}

The antenna model describes the effects of the physical device which converts
electric signals into radio waves, and vice versa. This model captures the
antenna characteristics that heavily affect the quality of the communication
channel. For example, various antenna shapes, antenna size and geometry, antenna
arrays, and antenna orientation causes different directional or frequency
selectivity.

The antenna model provides a position and an orientation using a mobility model
that defaults to the mobility of the node. The main purpose of this model is to
compute the antenna gain based on the specific antenna characteristics and the
direction of the signal. The signal direction is computed by the medium from the
position and the orientation of the transmitter and the receiver. The following
list provides some examples:

\begin{itemize}
  \item \nedtype{IsotropicAntenna}: antenna gain is exactly 1 in any direction
  \item \nedtype{ConstantGainAntenna}: antenna gain is a constant determined by
    a parameter
  \item \nedtype{DipoleAntenna}: antenna gain depends on the direction according
    to the dipole antenna characteristics
  \item \nedtype{InterpolatingAntenna}: antenna gain is computed by linear
    interpolation according to a table indexed by the direction angles
\end{itemize}

\subsection{Transmitter Models}

The transmitter model describes the physical process which converts packets into
electric signals. In other words, this model converts an L2 frame into a signal
that is transmitted on the medium. The conversion process and the representation
of the signal depends on the level of detail and the physical characteristics
of the implemented protocol.

There are two main levels of detail (or modeling depths):
 
\begin{itemize}
\item In the \textit{flat model}, the transmitter model skips the symbol domain 
and the sample domain representations, and it directly creates the analog domain 
representation. The bit domain representation is reduced to the bit length of 
the packet, and the actual bits are ignored.

\item In the \textit{layered model}, the conversion process involves various 
processing steps such as packet serialization, forward error correction encoding, 
scrambling, interleaving, and modulation. This transmitter model requires 
significantly more computation, but it produces accurate bit domain, 
symbol domain, and sample domain representations.
\end{itemize}

Some of the transmitter types available in INET:

\begin{itemize}
  \item \nedtype{UnitDiskTransmitter}
  \item \nedtype{ApskScalarTransmitter}
  \item \nedtype{ApskDimensionalTransmitter}
  \item \nedtype{ApskLayeredTransmitter}
  \item \nedtype{Ieee80211ScalarTransmitter}
  \item \nedtype{Ieee80211DimensionalTransmitter}
\end{itemize}


\subsection{Receiver Models}

The receiver model describes the physical process which converts electric
signals into packets. In other words, this model converts a reception, along
with an interference computed by the medium model, into a MAC packet and a
reception indication.

For a packet to be received successfully, reception must be \textit{possible}
(based on reception power, bandwidth, modulation scheme and other characteristics),
it must be \textit{attempted} (i.e. the receiver must synchronize itself on
the preamble and start receiving), and it must be \textit{successful} 
(as determined by the error model and the simulated part of the signal decoding).

In the \textit{flat model}, the receiver model skips the sample domain, the symbol domain,
and the bit domain representations, and it directly creates the packet domain
representation by copying the packet from the transmission. It uses the error
model to decide whether the reception is successful.

In the \textit{layered model}, the conversion process involves various processing steps
such as demodulation, descrambling, deinterleaving, forward error correction
decoding, and deserialization. This reception model requires much more
computation than the flat model, but it produces accurate sample domain, 
symbol domain, and bit domain representations.

Some of the receiver types available in INET:

\begin{itemize}
  \item \nedtype{UnitDiskReceiver}
  \item \nedtype{ApskScalarReceiver}
  \item \nedtype{ApskDimensionalReceiver}
  \item \nedtype{ApskLayeredReceiver}
  \item \nedtype{Ieee80211ScalarReceiver}
  \item \nedtype{Ieee80211DimensionalReceiver}
\end{itemize}


\subsection{Error Models}

Determining reception errors is a crucial part of the reception process.
There are often several different statistical error models in the literature
even for a particular physical layer. In order to support this diversity, the
error model is a separate replaceable component of the receiver. 

The error model describes how the signal to noise ratio affects the amount of
errors at the receiver. The main purpose of this model is to determine whether
the received packet has errors or not. It also computes various physical
layer indications for higher layers such as packet error rate, bit error rate,
and symbol error rate. For the layered reception model it needs to compute the
erroneous bits, symbols, or samples depending on the lowest simulated physical
domain where the real decoding starts. The error model is optional (if omitted,
all receptions are considered successful.)

The following list provides some examples:

\begin{itemize}
  \item \nedtype{StochasticErrorModel}: simplistic error model with constant
    symbol/bit/packet error rates as parameters; suitable for testing. 
  \item \nedtype{ApskErrorModel} 
  \item \nedtype{Ieee80211NistErrorModel}, \nedtype{Ieee80211YansErrorModel}, 
    \nedtype{Ieee80211BerTable\-Error\-Model}: various error models for IEEE 802.11
    network interfaces.
\end{itemize}

\subsection{Power Consumption Models}

A substantial part of the energy consumption of communication devices comes from
transmitting and receiving signals. The energy consumer model describes how the
radio consumes energy depending on its activity. This model is optional (if
omitted, energy consumption is ignored.) 

The following list provides some examples:

\begin{itemize}
  \item \nedtype{StateBasedEpEnergyConsumer}: power consumption is
    determined by the radio state (a combination of radio mode, 
    transmitter state and receiver state), and specified in 
    parameters like \fpar{receiverIdlePowerConsumption} and 
    \fpar{receiverReceivingDataPowerConsumption}, in watts.
  \item \nedtype{StateBasedCcEnergyConsumer}: similar to the previous
    one, but consumption is given in amp\`eres.
\end{itemize}

\section{Layered Radio Models}

In layered radio models, the transmitter and receiver models are split
to several stages to allow more fine-grained modeling. 

For transmission, processing steps such as packet serialization, 
forward error correction (FEC) encoding, scrambling, interleaving, and 
modulation are explicitly modeled. Reception involves the inverse
operations: demodulation, descrambling, deinterleaving, 
FEC decoding, and deserialization.

In layered radio models, these processing steps are encapsulated
in four stages, represented as four submodules in both the 
transmitter and receiver model: 

\begin{enumerate}
  \item \textit{Encoding and Decoding} describe how the packet domain 
    signal representation is converted into the bit domain, and vice versa.
  \item \textit{Modulation and Demodulation} describe how the bit domain
    signal representation is converted into the symbol domain, and vice versa.
  \item \textit{Pulse Shaping and Pulse Filtering} describe how the 
    symbol domain signal representation is converted into the sample domain, 
    and vice versa.
  \item \textit{Digital Analog and Analog Digital Conversion} describe 
    how the sample domain signal representation is converted into the 
    analog domain, and vice versa.
\end{enumerate}

In layered radio transmitters and receivers such as \nedtype{ApskLayeredTransmitter}
and \nedtype{ApskLayeredReceiver}, these submodules have parametric
types to make them replaceable. This provides immense freedom for 
experimentation.

\section{Notable Radio Models}

TODO there are a few, but 

\subsection{UnitDiskRadio}

TODO

UnitDiskRadio

        double communicationRange @unit(m);                              // the range where the reception of transmissions produced by this transmitter is possible
        double interferenceRange @unit(m) = default(communicationRange); // the range where transmissions produced by this transmitter interferes with other transmissions
        double detectionRange @unit(m) = default(interferenceRange);     // the range where transmissions produced by this transmitter can be detected at all

\begin{inifile}
*.radioMediumType = "UnitDiskRadioMedium"
*.host[*].wlan[*].radioType = "UnitDiskRadio"
*.host[*].wlan[*].radio.transmitter.bitrate = 2Mbps
*.host[*].wlan[*].radio.transmitter.preambleDuration = 0s
*.host[*].wlan[*].radio.transmitter.headerLength = 100b
*.host[*].wlan[*].radio.transmitter.communicationRange = 100m
*.host[*].wlan[*].radio.transmitter.interferenceRange = 0m    % FIXME wtf is this????
*.host[*].wlan[*].radio.transmitter.detectionRange = 0m
*.host[*].wlan[*].radio.receiver.ignoreInterference = true
\end{inifile}

*
        double communicationRange @unit(m);                              // the range where the reception of transmissions produced by this transmitter is possible
        double interferenceRange @unit(m) = default(communicationRange); // the range where transmissions produced by this transmitter interferes with other transmissions
        double detectionRange @unit(m) = default(interferenceRange);     // the range where transmissions produced by this transmitter can be detected at all



//
// This radio model provides a very simple but fast and predictable physical
// layer behavior. It must be used in conjunction with the ~UnitDiskRadioMedium
// model.
//
// The idea behind this radio model is to describe transmissions with a few
// distance based parameters: communication range, interference range, and
// detection range. Whether the reception is successful or not, depends on the
// distance between the transmitter and the receiver. This model is similar to
// the unit disk radio, but it's also more general than that. The ideal model
// also supports an ideal communication channel where all transmissions are
// received sucessfully independent of distance and interfering transmissions.
//
// See also ~UnitDiskRadioMedium, ~UnitDiskAnalogModel, ~UnitDiskTransmitter, and
// ~UnitDiskReceiver.


UnitDiskReceiver like IReceiver
        bool ignoreInterference = default(false);


//
// This transmitter model produces transmissions that are parameterized with
// communication range, interference range, and detection range. It also
// supports an ideal communication channel with configuring the range parameters
// to infinity.
//
// See also ~UnitDiskReceiver, ~UnitDiskRadio, ~UnitDiskRadioMedium, and
// ~UnitDiskAnalogModel.
//
module UnitDiskTransmitter like ITransmitter
        double preambleDuration @unit(s) = default(0s);                  // preamble added before the header
        int headerLength @unit(b) = default(96b);                     // number of header bits added to the length of the MAC frame
        double bitrate @unit(bps);                                       // the bitrate of the transmitter is used to compute the duration of the transmission
        double communicationRange @unit(m);                              // the range where the reception of transmissions produced by this transmitter is possible
        double interferenceRange @unit(m) = default(communicationRange); // the range where transmissions produced by this transmitter interferes with other transmissions
        double detectionRange @unit(m) = default(interferenceRange);     // the range where transmissions produced by this transmitter can be detected at all
        @class(UnitDiskTransmitter);
        @display("i=block/wtx");

Note: \nedtype{ShortcutInterface} provides an even simpler model...

\subsection{ApskRadio}

TODO

\subsection{IEEE 802.11 Radios}

TODO

\subsection{IEEE 802.15.4 Radios}

TODO

\subsection{UWB-IR Radios}

TODO

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "usman"
%%% End:

